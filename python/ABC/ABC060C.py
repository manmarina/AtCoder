N, T = map(int, input().split())
t = list(map(int, input().split()))

ans = T  # このTは最後の1回分のT!!（先に加算している!）
for i in range(N - 1):
    ans += min(T, t[i + 1] - t[i])

print(ans)

"""
シミュレーション
チャッピー

必要なのは“アルゴリズム”というより 数直線上の区間の和の長さ を一次元でスキャンするだけのテクニックです。

核心アイデア
各回の入浴は区間 [t_i, t_i+T) を覆います。
連続する2回の開始時刻の差 Δ = t_{i+1} - t_i が
Δ ≥ T なら前の区間と次の区間は重ならず、前の回はフルに T 継続。
Δ < T なら重なっており、前の回が次の開始で打ち切られるので有効時間は Δ。
"""
