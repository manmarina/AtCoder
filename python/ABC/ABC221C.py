s = input().strip()          # N
d = list(map(int, s))
k = len(d)
ans = 0

# 1..(1<<k)-2 : A, B がどちらも空でない
# 全て0にならないように1よりスタート
# 全て1にならないように(1 << k) - 1で終了
for mask in range(1, (1 << k) - 1):
    A, B = [], []
    for i in range(k):
        if (mask >> i) & 1:  # 切れ目ではなく文字自体をマスク <- ここ重要！！
            A.append(d[i])  # maskが1のときはAへ
        else:
            B.append(d[i])  # maskが0のときはBへ

    # 各グループ内で降順にして数値化
    A.sort(reverse=True)
    B.sort(reverse=True)

    # 先頭ゼロケア：降順なので、非ゼロがあれば先頭非ゼロ
    # もし「正の整数のみ可」なら A[0]==0 や B[0]==0 の場合をスキップする。
    # 本問は 0 を許容しても AC します（気になるなら次の2行を有効化）
    # if A[0] == 0 or B[0] == 0:
    #     continue

    a = 0
    for x in A:
        a = a * 10 + x
    b = 0
    for x in B:
        b = b * 10 + x

    ans = max(ans, a * b)

print(ans)

"""
ビット全探索 bit全探索（部分集合列挙）+貪欲（各グループ内で降順並べ）
根拠は並べ替え不等式（同じ桁集合なら、桁を大きい順に並べたときが数値として最大）
チャッピー

切れ目ではなく文字自体をマスクして選択するところがとても重要！！

アルゴリズム
    N を文字列にして各桁配列 d を得る（長さを k とする）。
    すべての非自明な部分集合 mask（1 … (1<<k)-2）を列挙し、
    mask 側の桁を A 用、残りを B 用に振り分ける。
    それぞれの桁を降順ソートしてから連結して整数化（先頭が 0 にならない）。
    積 A*B を更新して最大値を答えに。
    桁を降順にする理由：同じ桁集合で最も大きな数は降順並べだから（=先頭に大きい桁を置くのが得）。

    先頭 0 問題：降順にすると、非ゼロが1つでもあれば先頭は必ず非ゼロ。
    全て 0 のときのみ 0 になるが、そのままで OK
    （0 は正の整数ではないが、問題文が「正の整数」指定なら 0 を作る分割は無視する。
    AtCoder本問では 0 を許していたはずですが、不安なら A,B のどちらかが 0 になった分割をスキップしても AC します）。
"""
