import sys

input = sys.stdin.readline
N = int(input())
S = list(map(int, input().split()))
T = list(map(int, input().split()))

# 開始は T が最小の位置
k = min(range(N), key=lambda i: T[i])

ans = [10**19] * N
ans[k] = T[k]

# 円環を1周だけ進みながら緩和
"""
「chmin」緩和とは
    change minimum の略。
    「ある変数に入っている値を、候補値と比べて小さい方に更新する」処理を指します。
"""
i = k
for _ in range(N - 1):
    j = (i + 1) % N
    # chmin: 直接もらうか、前から回ってくるか
    ans[j] = min(T[j], ans[i] + S[i])
    i = j

print(*ans, sep="\n")

"""
最短路（shortest path）問題
チャッピー

ざっくり言うと「円環上の最短伝播」を一周で緩和していく問題です。
使うテクニックは次のとおり。

何をやる問題？
人（0…N-1）が円環状に並んでいて、i が持っている宝石は S[i] 時間で (i+1) へ渡せる（i→i+1 の有向辺、重み S[i]）。
各 i は「外部から最初に手に入る時刻」T[i] も与えられる（多源的な初期距離）。
各 i の最も早い受け取り時刻 ans[i] を求める。
これは「非負辺の有向グラフ（円環）で、多数の始点を持つ最短時間」を求めるのと同じです。

解法のコア（円環一周の緩和）
最小の T[i] を持つ頂点 k を見つける。ここは必ず最初に確定してよい（他から回ってくるより早い）。
ans[k] = T[k] を確定として、k, k+1, k+2, … と円環に沿って 1 周だけ 進む。
毎歩、次の式で「chmin」緩和する：

ans[next] = min(T[next], ans[cur] + S[cur])

これを N 回（=1 周）行うと、全頂点の最短時刻が確定する。

なぜ 1 周で良いの？
円環の各辺は i→i+1 の一方向のみ。最短路は「どこかの T[x] から始まって時計回りに何本か進む」形に限られます。
最小 T[k] から出発して一周歩く間に、各頂点は
    外から直接来る T[i]
    直前頂点からの伝播 ans[i-1] + S[i-1]
のどちらか早い方で一度だけ正しく緩和されます。時計回り単調1回の伝播で十分、というわけです。
"""
