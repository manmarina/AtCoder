N = int(input())
A = list(map(int, input().split()))

color = [0] * 9
for a in A:
    if a < 400:
        color[0] = 1
    elif a < 800:
        color[1] = 1
    elif a < 1200:
        color[2] = 1
    elif a < 1600:
        color[3] = 1
    elif a < 2000:
        color[4] = 1
    elif a < 2400:
        color[5] = 1
    elif a < 2800:
        color[6] = 1
    elif a < 3200:
        color[7] = 1
    else:
        color[8] += 1

# print(color)
mn = sum(color[:-1])
# ここが重要!! 全員が3200点以上のとき、最小値は0ではなくて1になることを見逃さない！！
print(1 if mn == 0 else mn, sum(color))

"""
場合分け系
自力解(WA けんちょんのコメントで原因がわかった)

N人がいてそれぞれの AtCoder レーティングが与えれている。
今、レーティング 3200 以上の人は自由に色を変えることができる。このとき、N
 人の中に存在する色の種類数の最大値と最小値を求めよ。

最大値について
最大値の方は簡単だ。3200 以上の人を全員別々の色 (しかも 3200 未満の人たちの色とも別の色) にすればよい。
よって、求める最大値は次のようになる。
(0〜3200 の範囲で登場している色の個数) + (3200 以上の人数)

最小値について
今度は 3200 以上の人がなるべく一致するようにさせたい。
ここで罠があって、全員が 3200 以上だったら、求める最小値は「1 通り」（全員を同じ色にする）である。
このケースを見落としがちな気がする。

3200 未満の人が一人でもいたら、3200 以上の人は全員その人に色を合わせればよい。
この場合は、求める最小値は(0〜3200 の範囲で登場している色の個数)
"""

"""
レート 1-399 : 灰色
レート 400-799 : 茶色
レート 800-1199 : 緑色
レート 1200-1599 : 水色
レート 1600-1999 : 青色
レート 2000-2399 : 黄色
レート 2400-2799 : 橙色
レート 2800-3199 : 赤色
"""
